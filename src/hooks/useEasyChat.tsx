import { useState, useCallback, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from './useAuth';

interface EasyChatQuestion {
  id: string;
  question_text: string;
  category: string;
  is_root: boolean;
  parent_question_id: string | null;
  response_leads_to: Record<string, string>;
}

interface EasyChatSession {
  id: string;
  user_id: string;
  patient_id: string | null;
  session_data: any;
  completed: boolean;
  created_at: string;
  updated_at: string;
  current_question_id: string | null;
  final_summary: string | null;
}

interface EasyChatResponse {
  id: string;
  session_id: string;
  question_id: string;
  response_value: string;
  response_text: string;
  created_at: string;
}

interface DynamicQuestion {
  question: string;
  options: string[];
}

export const useEasyChat = (patientId?: string, selectedAnatomy?: string[]) => {
  const { user } = useAuth();
  const [currentQuestion, setCurrentQuestion] = useState<EasyChatQuestion | null>(null);
  const [currentSession, setCurrentSession] = useState<EasyChatSession | null>(null);
  const [responses, setResponses] = useState<EasyChatResponse[]>([]);
  const [conversationPath, setConversationPath] = useState<Array<{ question: EasyChatQuestion; response: string }>>([]);
  const [loading, setLoading] = useState(false);
  const [dynamicQuestion, setDynamicQuestion] = useState<DynamicQuestion | null>(null);
  const [healthTopics, setHealthTopics] = useState<any[]>([]);
  const [useDynamicQuestions, setUseDynamicQuestions] = useState(false);
  const [isRecoveringSession, setIsRecoveringSession] = useState(false);

  const completeSession = useCallback(async (path: Array<{ question: EasyChatQuestion; response: string }>) => {
    if (!currentSession) return;

    try {
      // Generate summary based on responses
      const summary = generateSummary(path);

      // Update session as completed
      await supabase
        .from('easy_chat_sessions')
        .update({ 
          completed: true, 
          final_summary: summary,
          session_data: { 
            conversation_path: path.map(p => ({ 
              question_id: p.question?.id || 'dynamic', 
              question_text: p.question?.question_text || 'Dynamic question', 
              response: p.response 
            })),
            topics_for_doctor: path.map(p => ({
              topic: p.response,
              category: p.question?.category || 'general',
              confidence: 0.8,
              created_at: new Date().toISOString()
            }))
          }
        })
        .eq('id', currentSession.id);

      setCurrentSession(prev => prev ? { ...prev, completed: true, final_summary: summary } : null);
      setCurrentQuestion(null);
      setDynamicQuestion(null);
    } catch (error) {
      console.error('Error completing session:', error);
    }
  }, [currentSession]);

  const generateSummary = (path: Array<{ question: EasyChatQuestion; response: string }>) => {
    const questionsAndAnswers = path.map(p => {
      const questionText = p.question?.question_text || 'Question';
      return `Q: ${questionText}\nA: ${p.response}`;
    }).join('\n\n');
    
    const topics = path.map(p => `• ${p.response}`).join('\n');
    
    return `DrKnowsIt - AI Health Assistant
www.drknowsit.com

EASY CHAT SESSION SUMMARY

CONVERSATION DETAILS:
${questionsAndAnswers}

HEALTH DISCUSSION TOPICS FOR YOUR DOCTOR VISIT:
Based on your consultation, here are the key topics to discuss with your healthcare provider:

${topics}

NEXT STEPS:
• Schedule an appointment with your healthcare provider
• Bring this summary to your visit
• Be prepared to provide additional details about timing, severity, and any related symptoms
• Consider any questions you want to ask your doctor

This summary was generated by DrKnowsIt AI to help prepare you for your medical consultation. Always consult with qualified healthcare professionals for medical advice.`;
  };

  const checkIfReadyToComplete = useCallback(async (path: Array<{ question: EasyChatQuestion; response: string }>) => {
    try {
      const conversationContext = path.map(step => 
        `Q: ${step.question?.question_text || 'Unknown question'} A: ${step.response}`
      ).join('\n');

      const { data, error } = await supabase.functions.invoke('evaluate-easy-chat-completeness', {
        body: { 
          conversation_context: conversationContext,
          patient_id: patientId || '',
          conversation_length: path.length
        }
      });

      if (error) {
        console.error('Error checking completion readiness:', error);
        return path.length >= 10; // Fallback to length-based completion (minimum 10 questions)
      }

      return data?.should_complete || false;
    } catch (error) {
      console.error('Failed to check completion readiness:', error);
      return path.length >= 10; // Fallback to length-based completion (minimum 10 questions)
    }
  }, [patientId]);

  const generateNextQuestion = useCallback(async () => {
    try {
      console.log('Generating next dynamic question...');
      console.log('Current conversation path length:', conversationPath.length);
      conversationPath.forEach((item, index) => {
        console.log(`Path ${index + 1}: Q="${item.question?.question_text}" A="${item.response}"`);
      });
      
        const { data, error } = await supabase.functions.invoke('generate-easy-chat-question', {
          body: { 
            conversationPath,
            patientId,
            anatomyContext: selectedAnatomy && selectedAnatomy.length > 0 
              ? `Body areas of interest: ${selectedAnatomy.join(', ')}`
              : ''
          }
        });

      if (error) {
        console.error('Error generating question:', error);
        throw error;
      }

      console.log('Generated question data:', data);
      setDynamicQuestion(data);
      
    } catch (error) {
      console.error('Failed to generate next question:', error);
      // Fallback to completion if generation fails
      const newPath = [...conversationPath];
      await completeSession(newPath);
    }
  }, [conversationPath, patientId, completeSession]);

  const recoverActiveSession = useCallback(async () => {
    if (!user?.id || isRecoveringSession) return null;
    
    try {
      setIsRecoveringSession(true);
      console.log('Checking for existing active session...');
      
      // Only look for sessions created within the last 30 minutes
      const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000).toISOString();
      
      const { data: existingSessions, error } = await supabase
        .from('easy_chat_sessions')
        .select(`
          *,
          easy_chat_responses (*)
        `)
        .eq('user_id', user.id)
        .eq('completed', false)
        .gte('created_at', thirtyMinutesAgo)
        .order('created_at', { ascending: false })
        .limit(1);

      if (error) {
        console.error('Error checking for existing sessions:', error);
        return null;
      }

      // Mark old incomplete sessions as abandoned
      const { error: abandonError } = await supabase
        .from('easy_chat_sessions')
        .update({ 
          completed: true, 
          final_summary: 'Session abandoned - started new session',
          updated_at: new Date().toISOString()
        })
        .eq('user_id', user.id)
        .eq('completed', false)
        .lt('created_at', thirtyMinutesAgo);

      if (abandonError) {
        console.error('Error marking old sessions as abandoned:', abandonError);
      }

      if (existingSessions && existingSessions.length > 0) {
        const session = existingSessions[0];
        console.log('Found recent active session:', session.id, 'created:', session.created_at);
        
        // Restore conversation path from responses
        const sessionResponses = session.easy_chat_responses || [];
        const restoredPath = sessionResponses.map((resp: any) => ({
          question: { question_text: `Question ${resp.question_id}` } as EasyChatQuestion,
          response: resp.response_text
        }));
        
        setCurrentSession(session);
        setConversationPath(restoredPath);
        setResponses(sessionResponses);
        
        // Determine current state
        if (session.current_question_id) {
          // Try to load the current question
          const { data: question } = await supabase
            .from('easy_chat_questions')
            .select('*')
            .eq('id', session.current_question_id)
            .single();
            
          if (question) {
            setCurrentQuestion(question as EasyChatQuestion);
          } else {
            setUseDynamicQuestions(true);
          }
        } else {
          setUseDynamicQuestions(true);
        }
        
        return session;
      }
      
      console.log('No recent active sessions found, will start fresh');
      return null;
    } catch (error) {
      console.error('Error recovering session:', error);
      return null;
    } finally {
      setIsRecoveringSession(false);
    }
  }, [user?.id, isRecoveringSession]);

  const startNewSession = useCallback(async (forceNew = false) => {
    console.log('Starting Easy Chat session, forceNew:', forceNew, 'user:', user?.id);
    if (!user?.id) {
      console.log('No user found, cannot start session');
      return;
    }

    // Prevent starting multiple sessions simultaneously
    if (loading && !forceNew) {
      console.log('Session already starting, skipping...');
      return;
    }

    // If forcing new, abandon any existing incomplete sessions first
    if (forceNew) {
      console.log('Forcing new session - abandoning any existing incomplete sessions');
      try {
        const { error: abandonError } = await supabase
          .from('easy_chat_sessions')
          .update({ 
            completed: true, 
            final_summary: 'Session abandoned - user started new session',
            updated_at: new Date().toISOString()
          })
          .eq('user_id', user.id)
          .eq('completed', false);

        if (abandonError) {
          console.error('Error abandoning existing sessions:', abandonError);
        }
      } catch (error) {
        console.error('Error during session abandonment:', error);
      }
    }

    // Check for existing active session first (unless forced new)
    if (!forceNew && !currentSession) {
      const existingSession = await recoverActiveSession();
      if (existingSession) {
        console.log('Recovered existing session instead of starting new');
        return;
      }
    }

    try {
      setLoading(true);
      console.log('Creating new session with patient_id:', patientId);
      
      // Reset states completely
      setCurrentQuestion(null);
      setDynamicQuestion(null);
      setUseDynamicQuestions(false);
      setConversationPath([]);
      setResponses([]);
      setCurrentSession(null);
      
      const sessionDataObj = { 
        started_at: new Date().toISOString(),
        ...(selectedAnatomy && selectedAnatomy.length > 0 ? { selected_anatomy: selectedAnatomy } : {})
      };

      // Create new session
      const { data: newSessionData, error: sessionError } = await supabase
        .from('easy_chat_sessions')
        .insert({
          user_id: user.id,
          patient_id: patientId || null,
          current_question_id: null,
          session_data: sessionDataObj
        })
        .select()
        .single();

      if (sessionError) {
        console.error('Session creation error:', sessionError);
        throw sessionError;
      }

      console.log('Session created:', newSessionData);
      setCurrentSession(newSessionData);

      // If anatomy is selected, start with anatomy-specific questions, otherwise use root questions
      let questionQuery;
      
      if (selectedAnatomy && selectedAnatomy.length > 0) {
        // Map anatomy selections to anatomy-specific questions
        const anatomyMap: { [key: string]: string } = {
          'head': 'anatomy_head_start',
          'chest': 'anatomy_chest_start', 
          'abdomen': 'anatomy_abdomen_start',
          'back': 'anatomy_back_start',
          'arms': 'anatomy_arms_start',
          'legs': 'anatomy_legs_start',
          'neck': 'anatomy_neck_start'
        };
        
        const firstAnatomy = selectedAnatomy[0].toLowerCase();
        const anatomyQuestionId = anatomyMap[firstAnatomy];
        
        if (anatomyQuestionId) {
          questionQuery = supabase
            .from('easy_chat_questions')
            .select('*')
            .eq('id', anatomyQuestionId)
            .limit(1);
        } else {
          questionQuery = supabase
            .from('easy_chat_questions')
            .select('*')
            .eq('is_root', true)
            .limit(1);
        }
      } else {
        questionQuery = supabase
          .from('easy_chat_questions')
          .select('*')
          .eq('is_root', true)
          .limit(1);
      }

      const { data: startingQuestions, error: questionError } = await questionQuery;

      if (questionError || !startingQuestions || startingQuestions.length === 0) {
        console.error('Error fetching starting questions:', questionError);
        // Fallback to anatomy-aware dynamic question if available
        const anatomyContext = selectedAnatomy && selectedAnatomy.length > 0 
          ? `Selected anatomy: ${selectedAnatomy.join(', ')}`
          : '';
          
        setDynamicQuestion({
          question: selectedAnatomy && selectedAnatomy.length > 0 
            ? `What brings you to discuss your ${selectedAnatomy[0].toLowerCase()} today?`
            : "What brings you here today? What's your main health concern?",
          options: [
            "I have pain or discomfort",
            "I'm feeling unwell or sick", 
            "I have questions about my health",
            "I have concerns about changes I've noticed",
            "I want to discuss my general wellness",
            "I have mental health concerns",
            "I have other concerns as well"
          ]
        });
        setUseDynamicQuestions(true);
      } else {
        // Use the starting question (either anatomy-specific or root)
        const startingQuestion = startingQuestions[0] as EasyChatQuestion;
        setCurrentQuestion(startingQuestion);
        
        // Update session with current question
        await supabase
          .from('easy_chat_sessions')
          .update({ 
            current_question_id: startingQuestion.id,
            updated_at: new Date().toISOString()
          })
          .eq('id', newSessionData.id);
      }

    } catch (error) {
      console.error('Error starting easy chat session:', error);
      // Set a fallback state so the component doesn't break
      setDynamicQuestion({
        question: "What brings you here today? What's your main health concern?",
        options: [
          "I have pain or discomfort",
          "I'm feeling unwell or sick", 
          "I have questions about my health",
          "I have concerns about changes I've noticed",
          "I want to discuss my general wellness",
          "I have mental health concerns",
          "I have other concerns as well"
        ]
      });
      setUseDynamicQuestions(true);
    } finally {
      setLoading(false);
    }
  }, [user?.id, patientId, loading, currentSession, recoverActiveSession]);

  const submitTextResponse = useCallback(async (textResponse: string) => {
    if (!currentSession || !user) {
      console.error('Cannot submit text response: missing session or user');
      return;
    }

    try {
      setLoading(true);
      console.log('Submitting text response:', textResponse);

      // Create a fake question for text responses
      const fakeQuestionId = `text_input_${Date.now()}`;
      
      const { error: responseError } = await supabase
        .from('easy_chat_responses')
        .insert({
          session_id: currentSession.id,
          question_id: fakeQuestionId,
          response_value: 'text_input',
          response_text: textResponse
        });

      if (responseError) {
        console.error('Error saving text response:', responseError);
      }

      // Update conversation path
      const currentQuestionText = useDynamicQuestions && dynamicQuestion 
        ? dynamicQuestion.question 
        : currentQuestion?.question_text || 'Describe your concerns';
        
      const newPath = [...conversationPath, { 
        question: { question_text: currentQuestionText } as EasyChatQuestion, 
        response: textResponse 
      }];
      setConversationPath(newPath);

      // Check if we should complete after text input
      const shouldComplete = await checkIfReadyToComplete(newPath);
      if (shouldComplete) {
        console.log('AI is confident about health topics after text input, completing session');
        await completeSession(newPath);
      } else if (newPath.length >= 15) {
        console.log('Reached absolute maximum questions after text input, completing session');
        await completeSession(newPath);
      } else {
        console.log('Continuing conversation after text input, switching to AI questions');
        setUseDynamicQuestions(true);
        await generateNextQuestion();
      }
      
    } catch (error) {
      console.error('Error submitting text response:', error);
    } finally {
      setLoading(false);
    }
  }, [currentSession, currentQuestion, user, conversationPath, completeSession, useDynamicQuestions, dynamicQuestion, checkIfReadyToComplete, generateNextQuestion]);

  const submitResponse = useCallback(async (responseValue: string, responseText: string) => {
    if (!currentSession || !user) {
      console.error('Cannot submit response: missing session or user');
      return;
    }

    // Handle "I have other concerns as well" - this should trigger text input mode, not completion
    if (responseValue === 'other_concerns') {
      console.log('User selected other concerns, showing text input for custom response');
      // Don't complete here - let the user type their response and continue the flow
      return 'show_text_input';
    }

    try {
      setLoading(true);
      console.log('Submitting response:', { responseValue, responseText });

      // Save the response for dynamic questions (create a fake question ID)
      if (useDynamicQuestions && dynamicQuestion) {
        const fakeQuestionId = `dynamic_${Date.now()}`;
        
        const { error: responseError } = await supabase
          .from('easy_chat_responses')
          .insert({
            session_id: currentSession.id,
            question_id: fakeQuestionId,
            response_value: responseValue,
            response_text: responseText
          });

        if (responseError) {
          console.error('Error saving response:', responseError);
        }

        // Update conversation path
        const newPath = [...conversationPath, { 
          question: { question_text: dynamicQuestion.question } as EasyChatQuestion, 
          response: responseText 
        }];
        setConversationPath(newPath);

        // Check if we have enough confident health topics before completing
        if (newPath.length >= 3) {
          const shouldComplete = await checkIfReadyToComplete(newPath);
          if (shouldComplete) {
            console.log('AI is confident about health topics, completing session');
            await completeSession(newPath);
          } else if (newPath.length >= 15) {
            console.log('Reached absolute maximum questions, completing session');
            await completeSession(newPath);
          } else {
            await generateNextQuestion();
          }
        } else {
          await generateNextQuestion();
        }
        
      } else if (currentQuestion) {
        // Original logic for hardcoded questions
        const { error: responseError } = await supabase
          .from('easy_chat_responses')
          .insert({
            session_id: currentSession.id,
            question_id: currentQuestion.id,
            response_value: responseValue,
            response_text: responseText
          });

        if (responseError) {
          console.error('Error saving response:', responseError);
          throw responseError;
        }

        // Update conversation path
        const newPath = [...conversationPath, { question: currentQuestion, response: responseText }];
        setConversationPath(newPath);

        // Check if this response leads to another question
        const nextQuestionId = currentQuestion.response_leads_to[responseValue];
        
        if (nextQuestionId) {
          console.log('Loading next question:', nextQuestionId);
          
          const { data: nextQuestion, error: questionError } = await supabase
            .from('easy_chat_questions')
            .select('*')
            .eq('id', nextQuestionId)
            .single();

          if (questionError) {
            console.error('Error fetching next question:', questionError);
            // Switch to dynamic questions if hardcoded fails
            setUseDynamicQuestions(true);
            await generateNextQuestion();
            return;
          }

          if (nextQuestion) {
            setCurrentQuestion(nextQuestion as EasyChatQuestion);
            
            // Update session with new current question
            const { error: updateError } = await supabase
              .from('easy_chat_sessions')
              .update({ 
                current_question_id: nextQuestion.id,
                updated_at: new Date().toISOString()
              })
              .eq('id', currentSession.id);

            if (updateError) {
              console.error('Error updating session:', updateError);
            }
          }
        } else {
          // No more hardcoded questions, switch to dynamic
          console.log('Switching to AI-generated questions after first response');
          setUseDynamicQuestions(true);
          await generateNextQuestion();
        }
      }
    } catch (error) {
      console.error('Error submitting response:', error);
    } finally {
      setLoading(false);
    }
  }, [currentSession, currentQuestion, user, conversationPath, completeSession, useDynamicQuestions, dynamicQuestion, generateNextQuestion, checkIfReadyToComplete]);

  const getResponseOptions = useCallback(() => {
    if (useDynamicQuestions && dynamicQuestion) {
      return dynamicQuestion.options.map((option, index) => ({
        value: option === 'I have other concerns as well' ? 'other_concerns' :
               `option_${index}`,
        text: option
      }));
    }
    
    if (!currentQuestion) return [];

    const options = Object.entries(currentQuestion.response_leads_to)
      .filter(([value]) => value !== 'none_above'); // Filter out any remaining none_above
    
    // Convert the response_leads_to mapping to user-friendly options
    return options.map(([value, _]) => {
      let text = value;
      
      // Map common values to user-friendly text
      const valueMap: Record<string, string> = {
        'yes': 'Yes',
        'no': 'No',
        'mild': 'Mild',
        'moderate': 'Moderate', 
        'severe': 'Severe',
        'recent': 'Recently (within days)',
        'weeks': 'A few weeks ago',
        'months': 'Months ago',
        'years': 'Years ago',
        'morning': 'In the morning',
        'afternoon': 'In the afternoon',
        'evening': 'In the evening',
        'night': 'At night',
        'constant': 'All the time',
        'intermittent': 'Comes and goes',
        'stress_related': 'When I\'m stressed',
        'physical_activity': 'During physical activity',
        'rest': 'When I\'m resting',
        'eating': 'When eating',
        'sleeping': 'When sleeping'
      };
      
      return {
        value,
        text: valueMap[value] || value.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
      };
    });
  }, [currentQuestion, useDynamicQuestions, dynamicQuestion]);

  return {
    currentQuestion: useDynamicQuestions ? { question_text: dynamicQuestion?.question || '' } as EasyChatQuestion : currentQuestion,
    currentSession,
    responses,
    conversationPath,
    loading: loading || isRecoveringSession,
    startNewSession,
    submitResponse,
    submitTextResponse,
    getResponseOptions,
    isCompleted: currentSession?.completed || false,
    hasActiveSession: !!currentSession && !currentSession.completed,
    hasResponses: conversationPath.length > 0,
    completeSession,
    checkIfReadyToComplete,
    recoverActiveSession
  };
};
